function main()
%MAIN Summary of this function goes here
%   Detailed explanation goes here
    
    %% init parameters
    g = [0 0 -9.79]'; %for simulation
    integ = 'rect'; %ekf parameter
    alpha = 0;  %ekf parameter
    ekfSize = 16;  %ekf parameter
    imuHz_ds = 120; %how fast do the IMU measurements come in?
    domainID = 1; %ros2 domain
    
    mapfile = './resources/map.mat';
    map = load(fullfile(mapfile));
    T_uw2rw = map.worldObjectStruct.transforms.T_sim2world;
    T_imu2rq = map.worldObjectStruct.transforms.T_imu2genquad;
    T_rc2rq = map.worldObjectStruct.transforms.T_gencam2genquad;
    
    %% init ros2 subscribers
    imuNode = ros2node("ekf_node", domainID); %from the flight controller via the uXRCE agent
    imuSub = ros2subscriber(imuNode, '/fmu/out/sensor_combined', Reliability="besteffort");
    
    p3pNode = ros2node("p3p_node", domainID); %from the visual state estimator (camera + processing)
    p3pSub = ros2subscriber(p3pNode, 'p3p/pose_stamped', Reliability='besteffort');
    
    mocapNode = ros2Node("mocap_node", domainID); %ground truth from the motion capture system - could be in a separate thread - domain might be different!
    mocapSub = ros2subscriber(mocapNode, 'p3p/pose_stamped', Reliability='besteffort');
    
   
    %% *********************************************%%%
    % THIS IS WHERE THE CODE SHOULD START ON BUT
    %% init EKF
    x_k_ = zeros(ekfSize, 1); %bad initial guess
    x_k_(4,1) = 1; 
    dt_av = 1/imuHz_ds;
    [P_k_, Q, W_k] = EKF_3dQuad_funcs.initEKF_params(1/ekfHz, x_k_, ekfHz);
    %Q = 0.5*Q;
    W_k = W_k;    
    
    meas_count =  0; %how many frames used to correct so far? Used to initiate adaptive EKF
    meas_oldIndex = 0; %what was the last frame used? So we don't reuse frames
    count = 1;
    t0 = 0;
    lastCorrectionTime = 0;
    timeSinceLastCorrection = 999;
    
    %% run EKF
    %wait for first imu msg
    [~, t0] = getRos2Msg_imu(imuSub, 0);
    tPrev = t0;
    
    %MAIN STATE ESTIMATOR
    while 1 %could also be when called/stopped
        %check for new imu msg
        [u_new, tsNew] = getRos2Msg_imu(imuSub, tsPrev);
        dt_new = tsNew-tsPrev;
        dt_av = 0.9*dt_av + 0.1*dt_new;
    
        if ~isnan(u_new(1,1))
            
            %check for new p3p msg
            [z_new, lastCorrectionTime] = getRos2Msg_p3p(p3pSub, lastCorrectionTime);
            timeSinceLastCorrection = tsNew-lastCorrectionTime;  
            if ~isnan(z_new(1,1))
                meas_count = meas_count + 1;
            end
            
            dt_av_s = double(dt_av)*1e-6;
            [x_k_, P_k_, xHat_k, PHat_k, zHat_k, z_out_k, y_k, K_k, S_k, Q_k, W_k] = EKF_3dQuad_funcs.EKF_loop(g, x_k_, P_k_, u_new, Q, z_new, W_k, dt_av_s, integ, alpha, meas_count);
    
            count=count+1;  
            ekfResult.time = tsNew;
            ekfResult.x_ = x_k_;
            ekfResult.u = u_new;
            ekfResult.z = z_out_k;
            ekfResult.xHat = xHat_k; 
            ekfResult.zHat= zHat_k;
            ekfResult.elapsedTime = tsNew-t0;
            ekfResult.timeSinceLastCorrection= timeSinceLastCorrection;
            ekfResult.y = y_k; 
            ekfResult.K = K_k;
            ekfResult.P = P_k_; %these might still have zeroes in the lower triangle
            ekfResult.PHat = PHat_k;
            ekfResult.S = S_k;
            ekfResult.W = W_k;
            ekfResult.Q = Q_k;
    
            
            tsPrev = tsNew;
    
        end
    end
end


